Base0 Base_t [3,3]:
  Zone0 Zone_t [24,6,0]:
    GridCoordinates GridCoordinates_t:
      CoordinateX DataArray_t:
        R8 : [ 0,1,2,3,
               0,1,2,3,
               0,1,2,3,
               0,1,2,3,
               0,1,2,3,
               0,1,2,3 ]
      CoordinateY DataArray_t:
        R4 : [ 0,0,0,0,
               1,1,1,1,
               2,2,2,2,
               0,0,0,0,
               1,1,1,1,
               2,2,2,2 ]
      CoordinateZ DataArray_t:
        R4 : [ 0,0,0,0,
               0,0,0,0,
               0,0,0,0,
               1,1,1,1,
               1,1,1,1,
               1,1,1,1 ]
    ZoneBC ZoneBC_t:
      Inlet BC_t:
        GridLocation GridLocation_t "FaceCenter":
        PointList IndexArray_t [1,2]: # 1,2 are the two i-faces at x=0
    ZoneGridConnectivity ZoneGridConnectivity_t:
      MixingPlane GridConnectivity "Zone1":
        GridConnectivityType GridConnectivityType_t "Abutting1to1":
        GridLocation GridLocation_t "FaceCenter":
        PointList IndexArray_t [7]: # 7 is the bottom i-face at x=3
        PointListDonor IndexArray_t [1]: # cf. Zone1



  #  std_e::multi_index<int32_t,3> vertex_dims = {4,3,2};
  #  //auto quad_faces = generate_faces(vertex_dims) | ranges::to<std::vector>;
  #  std::vector<quad_4<int32_t>> quad_faces = generate_faces(vertex_dims) | ranges::to<std::vector>;
  #  maia::offset_vertices_ids(quad_faces,1); // CGNS is 1-indexed
  #  auto ngons = convert_to_interleaved_ngons(quad_faces) | to_cgns_vector(F.alloc());
  #
  #  I8 nb_i_faces = 8;
  #  I8 nb_j_faces = 9;
  #  I8 nb_k_faces = 12;
  #  int32_t nb_ngons = nb_i_faces + nb_j_faces + nb_k_faces;
  #
  #  auto i_faces_l_parent_elements = generate_faces_left_parent_cell_ids (vertex_dims,0);
  #  auto i_faces_r_parent_elements = generate_faces_right_parent_cell_ids(vertex_dims,0);
  #  auto j_faces_l_parent_elements = generate_faces_left_parent_cell_ids (vertex_dims,1);
  #  auto j_faces_r_parent_elements = generate_faces_right_parent_cell_ids(vertex_dims,1);
  #  // k-faces are considered interior (only for the sake of having interior nodes),
  #  // their parent is imaginary cell #42
  #  auto k_faces_l_parent_elements = ranges::views::repeat_n(42,nb_k_faces);
  #  auto k_faces_r_parent_elements = ranges::views::repeat_n(42,nb_k_faces);
  #
  #  auto parent_elements = ranges::views::concat(
  #    i_faces_l_parent_elements , j_faces_l_parent_elements, k_faces_l_parent_elements,
  #    i_faces_r_parent_elements , j_faces_r_parent_elements, k_faces_r_parent_elements
  #  ) | to_cgns_vector(F.alloc());
  #
  #  std_e::offset(parent_elements,1); // cgns indexing begin at 1
  #  std_e::multi_index<int,2> pe_dims = {(int)parent_elements.size()/2,2};
  #  auto parent_elts = view_as_md_array(parent_elements.data(),pe_dims);
  #  
  #  tree ngon_elts = F.newNgonElements(
  #    "Ngons",
  #    std_e::make_span(ngons),
  #    1,nb_ngons
  #  );
  #  emplace_child(ngon_elts,F.newDataArray("ParentElements", view_as_node_value(parent_elts)));
  #  emplace_child(zone,std::move(ngon_elts));
  #
  #  return zone;
